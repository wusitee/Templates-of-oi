# å›¾è®º

## åŸºæœ¬æ¦‚å¿µ

### å›¾

å›¾ç¤ºç”±ç‚¹å’Œè¾¹ç»„æˆ

å¦‚æœä¸€æ¡è¾¹é“¾æ¥ç›¸åŒé¡¶ç‚¹å«**è‡ªç¯**  

å¦‚æœä¸¤æ¡è¾¹é“¾æ¥ç›¸åŒçš„é¡¶ç‚¹å«**é‡è¾¹**  

æ¯ä¸ªè¾¹å’Œç‚¹éƒ½å¯ä»¥å¸¦æƒå€¼, å«åš**è¾¹æƒå’Œç‚¹æƒ**

è€Œå¯¹äºæœ‰å‘å›¾è€Œè¨€

- **ä¸€ä¸ªé¡¶ç‚¹å‘åˆ«çš„é¡¶ç‚¹è¿è¾¹çš„æ¡æ•°ç§°ä½œè¿™ä¸ªç»“ç‚¹çš„å‡ºåº¦**

- **åˆ«çš„é¡¶ç‚¹è¿è¾¹åˆ°ä¸€ä¸ªé¡¶ç‚¹çš„æ¡æ•°ç§°ä½œè¿™ä¸ªç»“ç‚¹çš„å…¥åº¦**

åœ¨**ç¨ å¯†å›¾**ä¸­, è¾¹çš„æ•°é‡è¶‹è¿‘äºç‚¹æ•°çš„å¹³æ–¹, å³$m \sim O(n^2)$

è€Œåœ¨**ç¨€ç–å›¾**ä¸­, è¾¹çš„æ•°é‡è¶‹è¿‘äºç‚¹æ•°, å³$m \sim O(n)$

### æ ‘

> æ ‘æ˜¯ä¸€ç§ç‰¹æ®Šçš„å›¾

- ä¸€æ£µæ ‘å…·æœ‰ $n$ ä¸ªé¡¶ç‚¹ï¼Œ$ğ‘› âˆ’ 1$ æ¡è¾¹ã€‚

- æ ‘ä¸Šçš„æ‰€æœ‰é¡¶ç‚¹ä¹‹é—´ç›¸äº’è¿é€šä¸”ä¸å­˜åœ¨ç¯ã€‚

- æ ‘ä¸Šä¸¤ç‚¹ä¹‹é—´ä»…å­˜åœ¨ä¸€æ¡ç®€å•è·¯å¾„ã€‚

### å­˜å›¾æ–¹å¼

#### é‚»æ¥çŸ©é˜µ

å¯¹äºä¸€æ¡ä»i åˆ° j çš„æœ‰å‘è¾¹, æˆ‘ä»¬ç”¨`G[i][j]=1`æ¥è¡¨ç¤ºè¿™æ¡è¾¹å­˜åœ¨.

é€‚ç”¨äº**ç¨ å¯†å›¾** 

```cpp
int G[maxn][maxn];
int main()
{
    int n;
    std::cin>>n;
    for(int i=0;i<n;i++)
    {
        int a,b;
        int w;//å¦‚æœæ˜¯å¸¦æƒå›¾
        std::cin>>a>>b>>w;
        G[a][b]=w;
        G[b][a]=w;//å¦‚æœæ˜¯æ— å‘å›¾
    }
}
```

#### é‚»æ¥é“¾è¡¨

æˆ‘ä»¬ä½¿ç”¨**vectoræ•°ç»„**åœ¨å­˜å‚¨æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„å‡ºè¾¹.

é€‚ç”¨äº**ç¨€ç–å›¾**

```cpp
#include<vector>
struct Edge
{
    int to,weight;
};
std::vector <Edge> edge[maxn];
int main()
{
    int n;
    std::cin>>n;
    for(int i=0;i<n;i++)
    {
        int a,b;
        int w;//å¦‚æœæ˜¯å¸¦æƒå›¾
        cin>>a>>b>>w;
        std::edge[a].push_back({b,weight});
        std::edge[b].push_back({a,weight});//å¦‚æœæ˜¯æ— å‘å›¾
    }
}
```

#### æ‰©å±•: **é“¾å¼å‰å‘æ˜Ÿ**

æˆ‘ä»¬ç”¨ä¸€ä¸ªheadæ•°ç»„æ¥è¡¨ç¤ºæ¯ä»¥è¿™ä¸ªç‚¹ä¸ºèµ·ç‚¹çš„ç¬¬ä¸€æ¡è¾¹, è®©åç”¨ä¸€ä¸ªedgeæ•°ç»„å­˜è¾¹çš„ç»ˆç‚¹, æƒå€¼ä»¥åŠä¸‹æ¡ä»¥è¿™ä¸ªç‚¹ä¸ºèµ·ç‚¹çš„è¾¹.

```cpp
struct Edge
{
    int to,weight,next=-1;
}edge[maxn*maxn];
int head[maxn];
int vst[maxn];
void dfs(int strat)
{
    for(int i=head[start],i!=-1,i=edge[i].next)
    {
        if(!vst[edge[i].to])
        {
            vst[edge[i].to]=true;
            dfs(edge[i].to);
        }
    }
}
//éå†
int main()
{
    int n;
    std::cin>>n;
    for(int i=0;i<n;i++)
    {
        int h,t,w;//è¡¨ç¤ºèµ·ç‚¹,ç»ˆç‚¹å’Œæƒå€¼
        std::cin>>h>>t>>w;
        edge[++edge[0]]={t,w,head[h]};//ä½¿ç”¨å¤´æ’æ³•
        head[h]=edge[0];
    }


}
```

## æ ‘çš„æ€§è´¨

ä¸€ä¸ªäºŒå‰æ ‘é€šå¸¸æœ‰ä¸‰ç§éå†æ–¹å¼: **å‰, ä¸­, ååºéå†**

- æ ¹å·¦å³

- å·¦æ ¹å³

- å·¦å³æ ¹

tips: çŸ¥é“ä¸­åºéå†å’Œå…¶å®ƒä»»æ„ä¸€ä¸ªå°±å¯ä»¥æ¨å‡ºå‰©ä¸‹çš„éå†é¡ºåº

## æ ‘çš„ç›´å¾„

> **æ ‘ä¸Šçš„ä¸€æ¡è·¯å¾„, æ»¡è¶³å…¶è¾¹æƒä¹‹å’Œæœ€å¤§**

å¦‚æœæ ‘ä¸Šçš„è¾¹æƒéè´Ÿçš„è¯, æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸¤æ¬¡æœç´¢çš„æ–¹å¼æ±‚å‡ºæ ‘çš„ç›´å¾„.

ç®—æ³•æµç¨‹

1. éšæœºæ‰¾åˆ°ä¸€ä¸ªç‚¹, é€šè¿‡æœç´¢æ‰¾åˆ°ç¦»è¿™ä¸ªç‚¹æœ€è¿œçš„ç‚¹$s$.

2. åœ¨ä»$s$å¼€å§‹æœç´¢, æ‰¾åˆ°ç¦»$s$æœ€è¿œçš„ç‚¹$t$

$s \rightarrow t$ å°±æ˜¯è¯¥æ ‘çš„ä¸€æ¡ç›´å¾„

<!-- ä¾‹é¢˜: P1099 -->

<!-- å’•å’•å’• -->

## ç”Ÿæˆæ ‘

åœ¨ä¸€å¼ æœ‰$n$ä¸ªèŠ‚ç‚¹å’Œ$m$æ¡è¾¹çš„è¿é€šå›¾ä¸Š, é€‰æ‹©å…¶ä¸­$n-1$æ¡è¾¹æ„æˆä¸€æ£µæ ‘, ä½¿å¾—æ‰€æœ‰èŠ‚ç‚¹è”é€š.

è€Œåœ¨ç”Ÿæˆæ ‘çš„æ‰€æœ‰è¾¹æƒå’Œæœ€å°æ—¶, è¿™æ£µæ ‘è¢«ç§°ä½œ**æœ€å°ç”Ÿæˆæ ‘**

åŒç†, ä¹Ÿæœ‰æœ€å¤§ç”Ÿæˆæ ‘.

### æ„å»ºæœ€å°ç”Ÿæˆæ ‘

1. å°†è¾¹æƒæ’åº

2. ä»å°åˆ°å¤§æ‰«ææ¯ä¸€æ¡è¾¹$(u,v,w)$

3. å¦‚æœ$u,v$å·²ç»åœ¨ä¸€ä¸ªè”é€šå—å†…, æˆ‘ä»¬æ è¿‡è¿™æ¡è¾¹

4. å¦åˆ™é€‰æ‹©è¿™ä¸€æ¡è¾¹, æŠŠ$u,v$æ‰€åœ¨çš„å—è”é€šåˆ°ä¸€èµ·

æ—¶é—´å¤æ‚åº¦: $O(m \log m)$

å…³äºè”é€šå—çš„æŸ¥æ‰¾å’Œåˆå¹¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**å¹¶æŸ¥é›†**æ¥å®ç°

è¿™å°±æ˜¯**Kruskal**ç®—æ³•.

å‚è€ƒä»£ç 

```cpp
#include <algorithm>
#include <iostream>

const int maxn = 1e4 + 10;
int fa[maxn];
struct edge
{
    int u, v, w;
    bool operator<(const edge a) const
    {
        return this->w < a.w;
    }
} e[maxn * maxn]; // å­˜è¾¹
int find(int x)
{
    return (x == fa[x]) ? x : (fa[x] = find(fa[x]));
}
void Merge(int a, int b)
{
    fa[find(a)] = find(b);
} // å¹¶æŸ¥é›†
int Kruskal(int m, int n) // mä¸ºè¾¹çš„æ•°é‡,nä¸ºç‚¹çš„æ•°é‡
{
    int sum = 0;
    for (int i = 1; i <= n; i++)
        fa[i] = i; // åˆå§‹åŒ–è”é€šå—
    std::sort(e + 1, e + m + 1);
    for (int i = 1; i <= m; i++)
    {
        auto [u, v, w] = e[i]; // c++17å¤§æ³•å¥½
        if (find(u) == find(v))
        {
            continue;
        }
        else
        {
            sum += w;
            Merge(u, v);
        }
    }
    return sum;
}
```

è™½ç„¶Kruskalç®—æ³•åœ¨ç¨€ç–å›¾ä¸Šè¿è¡Œè‰¯å¥½,ä½†æ˜¯åœ¨ç¨ å¯†å›¾è¾¹å¾ˆå¤šçš„æƒ…å†µä¸‹,æ¯”è¾ƒå®¹æ˜“è¶…æ—¶.

å¯¹äºä»¥ä¸Šçš„é—®é¢˜, æˆ‘ä»¬å¯ä»¥ç”¨**Prim**ç®—æ³•è§£å†³, æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$

### Primç®—æ³•

æˆ‘ä»¬å¯ä»¥å»ºç«‹ä¸€ä¸ª$dis$æ•°ç»„ä»£è¡¨å½“å‰ç”Ÿæˆæ ‘åˆ°è¯¥èŠ‚ç‚¹çš„æœ€çŸ­è¾¹é•¿

æˆ‘ä»¬å…ˆå°†1å·èŠ‚ç‚¹åŠ å…¥æ ‘, å¹¶ä¸”å¼€å§‹å¾ªç¯:

- è·Ÿæ–°disæ•°ç»„

- ä»disæ•°ç»„ä¸­æ‰¾åˆ°ç¦»å½“å…ˆç”Ÿæˆæ ‘æœ€è¿‘çš„èŠ‚ç‚¹åŠ å…¥æ ‘

æˆ‘ä»¬å¯ä»¥å‘ç°ä¸€å…±è¦æ‰¾$n$ä¸ªèŠ‚ç‚¹, åŒæ—¶æ¯æ‰¾ä¸€ä¸ªèŠ‚ç‚¹è¦æŠŠé•¿ä¸º$n$çš„$dis$æ•°ç»„æ›´æ–°ä¸€æ¬¡, æ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$

å‚è€ƒä»£ç :

```cpp
#include <iostream>
#include <algorithm>
#include <limits.h>

const int maxn = 1e4 + 10;
int G[maxn][maxn]; // é‚»æ¥çŸ©é˜µå­˜å›¾(å› ä¸ºæ˜¯ç¨ å¯†å›¾)
int dis[maxn];
bool used[maxn];
int Prim(int n)
{
    int sum = 0;
    for (int i = 1; i <= n; i++)
        dis[i] = G[1][i];
    used[1] = true; // å…ˆæŠŠèŠ‚ç‚¹1åŠ å…¥åˆ°æœ€å°ç”Ÿæˆæ ‘ä¸­,å¹¶æ›´æ–°åˆå§‹disæ•°ç»„
    for (int i = 1; i <= n - 1; i++)
    {
        int minn = INT_MAX, mind;
        for (int j = 1; j <= n; j++)
        {
            if (minn > dis[j] && !used[j])
            {
                minn = dis[j];
                mind = i;
            }
        } // æ‰¾åˆ°ç¦»å½“å‰ç”Ÿæˆæ ‘æœ€è¿‘çš„èŠ‚ç‚¹
        used[mind] = true;
        sum += minn; // æŠŠå®ƒåŠ å…¥ç”Ÿæˆæ ‘
        for (int j = 1; j <= n; j++)
        {
            dis[j] = std::min(dis[j], G[mind][j]);
        } // æ›´æ”¹å…¶ä»–èŠ‚ç‚¹
    }
    return sum;
}
```

ä¾‹é¢˜: P2872, P2330

å’•å’•å’•

## æœ€çŸ­è·¯é—®é¢˜

åœ¨ä¸€å¼ æœ‰$n$ä¸ªç»“ç‚¹ã€$m$æ¡è¾¹çš„å¸¦éè´Ÿè¾¹æƒçš„å›¾ä¸Šï¼Œæœ‰ä¸€ä¸ªèµ·ç‚¹$s$ã€‚
éœ€è¦æ±‚å‡ºä»èµ·ç‚¹å‡ºå‘åˆ°å…¶ä»–æ‰€æœ‰ç»“ç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚

å¯¹äºè¿™ç§å•æºéè´Ÿçš„æœ€çŸ­è·¯å¾„é—®é¢˜, æˆ‘ä»¬é€šå¸¸ä½¿ç”¨**dijkstra**ç®—æ³•æ¥è§£å†³è¿™ä¸€ç±»é—®é¢˜

### dijkstraç®—æ³•

- å®šä¹‰ä¸€ä¸ª$dis$æ•°ç»„,ç”¨æ¥è®°å½•åˆ°èµ·ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦

- ä»æ‰€æœ‰æ²¡æœ‰é€‰è¿‡çš„ç‚¹é€‰æ‹©ä¸€ä¸ªç¦»èµ·ç‚¹æœ€è¿‘çš„ç‚¹(å³$\min(dis)$), è®¾ä¸º$u$

- ä»$u$å‡ºå‘, å¯¹äºæ¯ä¸€æ¡è¾¹è¿›è¡Œæ¾å¼›æ“ä½œ, å³`dis[v]=min(dis[v],dis[u]+w)`

- å°†ç‚¹$u$æ ‡è®°ä¸ºå·²é€‰æ‹©è¿‡, é‡å¤ä¸Šè¿°æ“ä½œ

å…³äºæ­¤ç®—æ³•, æ¯ä¸€ä¸ªç‚¹éƒ½è¦è¢«é€‰å–ä¸€æ¬¡, æ¯æ¬¡æ¯ä¸€ä¸ªç‚¹éƒ½ä¼šè¢«è¿›è¡Œæ¾å¼›æ“ä½œ, æ•…æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$

å‚è€ƒä»£ç 

```cpp
#include <algorithm>
#include <limits.h>
const int maxn = 1e4 + 10;
int G[maxn][maxn];
int dis[maxn];
bool vst[maxn];
void dijkstra(int n, int stp)
{
    std::fill(dis + 1, dis + 1 + n, INT_MAX);//ä¼˜é›…
    vst[stp] = true;
    for (int i = 1; i <= n; i++)
    {
        dis[i] = std::min(dis[i], G[stp][i]);
    }//é¦–å…ˆä»èµ·ç‚¹å¼€å§‹æ¾å¼›
    for (int i = 1; i <= n - 1; i++)
    {
        int minn = INT_MAX, mind;
        for (int j = 1; j <= n; j++)
        {
            if (dis[j] < minn && !vst[j])
            {
                minn = dis[j];
                mind = j;
            }
        }//æ‰¾åˆ°ç¦»èµ·ç‚¹æœ€è¿‘çš„ç‚¹
        vst[mind] = true;
        for (int j = 1; j <= n; j++)
        {
            dis[j] = std::min(dis[j], G[mind][j]);
        }//æ¾å¼›
    }
}
```

åŒæ—¶å¯¹äºç¨€ç–å›¾, æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–, æ—¶é—´å¤æ‚åº¦: $O(m\log m)$

```cpp
#include <algorithm>
#include <queue>
#include <vector>
#include <limits.h>

const int maxn = 1e4 + 10;

struct Edge
{
    int to, weight;
    bool operator<(const Edge &a) const//ä¸åŠ constä¼šce
    {
        return this->weight < a.weight;
    }
};

std::vector<Edge> G[maxn]; // å­˜å‚¨å›¾çš„é‚»æ¥è¡¨
int dis[maxn];             // å­˜å‚¨èµ·å§‹èŠ‚ç‚¹åˆ°å„èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
bool vst[maxn];            // æ ‡è®°èŠ‚ç‚¹æ˜¯å¦å·²è®¿é—®è¿‡

void dijkstra(int n, int stp)
{
    std::priority_queue<Edge> p;              // ä¼˜å…ˆé˜Ÿåˆ—ï¼Œç”¨äºé€‰æ‹©å½“å‰æƒé‡æœ€å°çš„è¾¹
    std::fill(dis + 1, dis + n + 1, INT_MAX); // åˆå§‹åŒ–è·ç¦»æ•°ç»„ä¸ºæ­£æ— ç©·
    dis[stp] = 0;                             // èµ·å§‹èŠ‚ç‚¹åˆ°è‡ªèº«çš„è·ç¦»ä¸º0
    p.push({stp, 0});                         // å°†èµ·å§‹èŠ‚ç‚¹åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—

    while (!p.empty())
    {
        auto [u, w] = p.top(); // å¼¹å‡ºå½“å‰æƒé‡æœ€å°çš„è¾¹
        p.pop();

        if (vst[u])
            continue; // å¦‚æœèŠ‚ç‚¹å·²ç»è®¿é—®è¿‡ï¼Œè·³è¿‡

        vst[u] = true; // æ ‡è®°èŠ‚ç‚¹ä¸ºå·²è®¿é—®

        // éå†ä»èŠ‚ç‚¹uå¯è¾¾çš„æ‰€æœ‰è¾¹
        for (auto v : G[u])
        {
            auto [t, wei] = v; // tä¸ºç›®æ ‡èŠ‚ç‚¹ï¼Œweiä¸ºè¾¹çš„æƒé‡

            // å¦‚æœç»è¿‡èŠ‚ç‚¹uåˆ°è¾¾èŠ‚ç‚¹tçš„è·ç¦»æ›´çŸ­
            if (dis[t] > dis[u] + wei)
            {
                dis[t] = dis[u] + wei; // æ›´æ–°æœ€çŸ­è·ç¦»
                p.push({t, dis[t]});   // å°†èŠ‚ç‚¹tåŠå…¶æ–°è·ç¦»åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼Œä»¥ä¾¿åç»­å¤„ç†
            }
        }
    }
}
```

é‚£å¯¹äºæœ‰è´Ÿè¾¹æƒå€¼çš„æœ€çŸ­è·¯ï¼Œæˆ‘ä»¬åº”è¯¥å¦‚ä½•è§£å†³å‘¢

è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘ä»¬å¸¸å¸¸ä½¿ç”¨Bellman-fordç®—æ³•æ¥è§£å†³æ­¤ç±»é—®é¢˜ã€‚

ç®—æ³•æµç¨‹å¦‚ä¸‹ï¼š

1. å®šä¹‰ä¸€ä¸ª$dis$æ•°ç»„, è¡¨ç¤ºå½“å‰ä»èµ·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„è·ç¦»,

2. å¯¹äºæ¯æ¡è¾¹, æˆ‘ä»¬è¿›è¡Œä¸€æ¬¡æ¾å¼›æ“ä½œ.

3. é‡å¤ä»¥ä¸Šæ“ä½œ$n-1$æ¬¡

è¯¥ç®—æ³•çš„æ—¶é—´è´Ÿè½½åº¦ä¸º$O(n\cdot m)$

çœ‹èµ·æ¥æœ‰ç‚¹æ…¢, æˆ‘ä»¬è¯¥å¦‚ä½•ä¼˜åŒ–å‘¢.

å…¶å®æœ‰ä¸€ç§å«**spfa**çš„ç®—æ³•, å¯ä»¥çœ‹ä½œæ˜¯å¯¹å…¶çš„ä¼˜åŒ–, å…¶æµç¨‹å¦‚ä¸‹

- åŒæ ·å®šä¹‰ä¸€ä¸ªæ•°ç»„$dis$è¡¨ç¤ºèµ·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦», åŒæ—¶å®šä¹‰ä¸€ä¸ªé˜Ÿåˆ—$q$, æŠŠèµ·ç‚¹$s$åŠ å…¥$q$

- ä»é˜Ÿåˆ—ä¸­å–å‡ºä¸€ä¸ªèŠ‚ç‚¹$u$, æ¾å¼›ä¸$u$ç›¸è¿çš„æ‰€æœ‰è¾¹$(u,v)$, è‹¥æ¾å¼›æˆåŠŸ, ä¾¿æŠŠ$v$åŠ å…¥é˜Ÿåˆ—

- é‡å¤ä»¥ä¸Šæ“ä½œ

> **æ—¶é—´è´Ÿè½½åº¦: å…¶å®æœ¬è´¨ä¸Šæ¥è®²$spfa$ç®—æ³•çš„æ—¶é—´å¤«å†åº¦å’ŒBellman-fordæ˜¯ä¸€æ ·çš„, ä½†æ˜¯åœ¨å›¾éšæœºç”Ÿæˆçš„æƒ…å†µä¸‹$spfa$ä¼šå¿«çš„é£èµ·**

#### æ‰€ä»¥åœ¨ä½¿ç”¨æ­¤ç®—æ³•æ˜¯ä¸€å®šè¦è°¨æ…æŸ¥çœ‹$n\cdot m$çš„å¤§å°

å‚è€ƒä»£ç 

```cpp
#include <algorithm>
#include <queue>
#include <vector>
#include <limits.h>

const int maxn = 1e4 + 10;
std::queue<int> q;
int dis[maxn];
struct Edge
{
    int to, w;
    bool operator<(const Edge &a) const
    {
        return this->w < a.w;
    }
};
std::vector<Edge> g[maxn];
bool inq[maxn];

void spfa(int n, int stp)
{
    std::fill(dis + 1, dis + 1 + n, INT_MAX);
    dis[stp] = 0, inq[stp] = true;
    q.push(stp);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        inq[u] = false;
        for (auto v : g[u])
        {
            if (dis[v.to] > dis[u] + v.w)
            {
                dis[v.to] = dis[u] + v.w;
                if (!inq[v.to])
                {
                    q.push(v.to);
                    inq[v.to] = true;
                }
            }
        }
    }
}//å¥½åƒå¹¿æœ
```

é™¤æ­¤ä¹‹å¤–, spfaç®—æ³•è¿˜å¯ä»¥åˆ¤æ–­è´Ÿç¯çš„æƒ…å†µ, åœ¨è¿™ç§æƒ…å†µä¸‹ä¸å¯èƒ½å‡ºç°æœ€çŸ­è·¯çš„æ–¹æ³•.

é‚£ä¹ˆå¦‚ä½•åˆ¤æ–­æœ‰æ²¡æœ‰è´Ÿç¯å‘¢, æˆ‘ä»¬å¯ä»¥é€šè¿‡**åˆ¤æ–­æœ€çŸ­è·¯æœ‰æ²¡æœ‰ç»è¿‡ä¸å°‘äºnæ¡è¾¹çš„**æ–¹æ³•.

åœ¨è¿™ç§é—®é¢˜çš„æƒ…å†µä¸‹, æˆ‘ä»¬å¯ä»¥å¼€ä¸€ä¸ªlenæ•°ç»„æ¥è®°å½•æœ‰æ²¡æœ‰è´Ÿç¯

å‚è€ƒä»£ç 

```cpp
#include <algorithm>
#include <queue>
#include <vector>
#include <limits.h>
#include <iostream>

const int maxn = 1e4 + 10;
std::queue<int> q;
int dis[maxn],len[maxn];//åˆ¤æ–­è´Ÿç¯
struct Edge
{
    int to, w;
    bool operator<(const Edge &a) const
    {
        return this->w < a.w;
    }
};
std::vector<Edge> g[maxn];
bool inq[maxn];

void spfa_judge(int n)
{
    std::fill(dis + 1, dis + 1 + n, INT_MAX);
    dis[1] = 0, inq[1] = true;
    q.push(1);
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        inq[u] = false;
        for (auto v : g[u])
        {
            if (dis[v.to] > dis[u] + v.w)
            {
                dis[v.to] = dis[u] + v.w;
                len[v.to] = len[u] + 1;
                if(len[v.to] == n)//å¦‚æœæœ€çŸ­è·¯é•¿åº¦å¤§äºç­‰äºnï¼Œå°±è¯´æ˜æœ‰è´Ÿç¯
                {
                    puts("Yes");
                    return;
                }
                if (!inq[v.to])
                {
                    q.push(v.to);
                    inq[v.to] = true;
                }
            }
        }
    }
    puts("No");
} // å¥½åƒå¹¿æœ
```

<!-- ä¾‹é¢˜P1629 -->
<!---->
<!-- å’•å’•å’• -->

### å¤šæºæœ€çŸ­è·¯

æ— è®ºæ˜¯$Dijkstra$è¿˜æ˜¯$spfa$, å®ƒä»¬éƒ½æ˜¯å•æºæœ€çŸ­è·¯çš„ç®—æ³•, å³ä»å•ä¸ªèµ·ç‚¹å¼€å§‹,.é‚£ä¹ˆ,å¦‚æœæ˜¯å¤šä¸ªèµ·ç‚¹å‘¢, è¿™æ—¶,æˆ‘ä»¬å¯ä»¥ä½¿ç”¨$Floyd$ç®—æ³•æ¥è§£å†³.

#### $Floyd$

è¯¥ç®—æ³•åŸºäºåŠ¨æ€è§„åˆ’çš„æ€æƒ³

æˆ‘ä»¬å®šä¹‰$f_{k,i,j} $ä¸ºç»è¿‡äº†è‹¥å¹²ä¸ªç¼–å·ä¸è¶…è¿‡$k$çš„èŠ‚ç‚¹, ä»$i$åˆ°$j$çš„æœ€çŸ­è·¯å¾„.

å…¶æœ‰ä¸‰ç§è½¬ç§»æ–¹æ³•

- ä»è‹¥å¹²ä¸ªç¼–å·ä¸è¶…è¿‡$k-1$çš„èŠ‚ç‚¹è½¬ç§»è¿‡æ¥

- ä»èŠ‚ç‚¹$i$åˆ°èŠ‚ç‚¹$k$å†åˆ°èŠ‚ç‚¹$j$

å½¢å¼åŒ–çš„: $f_{k,i,j}=\min(f_{k-1,i,j},f_{k-1,i,k}+f_{k-1,k,j}) $

æ³¨æ„: åœ¨æšä¸¾æ—¶, è¦å…ˆæšä¸¾$k$

æ­¤å¤–ï¼Œğ‘“ æ•°ç»„çš„ç¬¬ä¸€ç»´å¯¹ç»“æœæ²¡æœ‰å½±å“ï¼Œå› æ­¤å¯ä»¥æ”¹å†™æˆï¼š
`ğ‘“[ğ‘–][ğ‘—] = min(ğ‘“[ğ‘–][ğ‘—], ğ‘“[ğ‘–][ğ‘˜] + ğ‘“[ğ‘˜][ğ‘—])`

æ—¶é—´å¤æ‚åº¦: $O(n^3)$ ~~ä»€ä¹ˆ, å’Œè·‘$n$éDijkstraä¸€æ ·é•¿?~~

å‚è€ƒä»£ç cpp

```cpp
#include<algorithm>
#include<iostream>
#include<limits.h>
#include<cstring>

const int maxn=1e4+10;
int f[maxn][maxn];

void Floryd(int n)
{
    for(int k=1;k<=n;k++)
    {
        f[k][k]=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
            {
                if(f[i][j]==-1) f[i][j]=INT_MAX;
                f[i][j]=std::min(f[i][j],f[i][k]+f[k][j]);
            }
    }
}

int main()
{
    int n,m;
    std::cin>>n>>m;
    std::memset(f,-1,sizeof(f));
    for(int i=0;i<m;i++)
    {
        int u,v,w;
        std::cin>>u>>v>>w;
        f[u][v]=w;
    }
    Floryd(n);
    return 0;
}
```

~~ä½ çœ‹çœ‹è¿™ç®€æ´çš„ä»£ç åœ¨è¯´è¯å¥½å—~~

## æ‹“æ‰‘æ’åº

å¯¹æœ‰å‘æ— ç¯å›¾ä¸Šçš„æ‰€æœ‰ç»“ç‚¹æ’åºï¼Œæ»¡è¶³æ’åœ¨å‰é¢çš„ç»“ç‚¹ä¸èƒ½ä¾èµ–äºæ’åœ¨åé¢çš„ç»“ç‚¹ï¼Œè¿™ç§æ–¹å¼è¢«ç§°ä¸ºæ‹“æ‰‘æ’åºã€‚

### æ‹“æ‰‘æ’åºçš„ä¸€èˆ¬æ–¹æ³•

- å°†æ‰€æœ‰å…¥åº¦ä¸º$0$çš„èŠ‚ç‚¹æ’å…¥é˜Ÿåˆ—

- å»é™¤é˜Ÿé¦–å…ƒç´ $u$, å°†å…¶è®¡å…¥ç­”æ¡ˆ

- åˆ é™¤ä¸$u$ç›¸è¿çš„æ‰€æœ‰è¾¹$(u,v) $è‹¥æ­¤æ—¶$v$çš„å…¥åº¦ä¸º$0$åˆ™å°†å…¶æ’å…¥é˜Ÿåˆ—

- é‡å¤ä»¥ä¸Šæµç¨‹ç›´åˆ°é˜Ÿåˆ—ä¸ºç©º

ä¾‹é¢˜:

P1113 æ‚åŠ¡
é¢˜æ„
æœ‰$n$é¡¹ä»»åŠ¡éœ€è¦å®Œæˆï¼Œç¬¬ä¸€é¡¹ä»»åŠ¡æ²¡æœ‰å‡†å¤‡å·¥ä½œï¼Œå…¶ä»–çš„ä»»åŠ¡å­˜åœ¨æœ‰å‡†å¤‡å·¥ä½œã€‚å·²çŸ¥æ¯é¡¹ä»»åŠ¡å®Œæˆæ‰€éœ€çš„æ—¶é—´ï¼Œæ±‚æ‰€æœ‰ä»»åŠ¡éƒ½è¢«å®Œæˆçš„æœ€çŸ­æ—¶é—´ã€‚å‡è®¾äº’ç›¸æ²¡æœ‰å…³ç³»çš„ä»»åŠ¡å¯ä»¥åŒæ—¶å·¥ä½œã€‚
æ•°æ®ä¿è¯ï¼Œ$3 \le n \le 10^4$

## å¼ºè¿é€šåˆ†é‡ä¸ç¼©ç‚¹

### å¼ºè¿é€šåˆ†é‡

åœ¨ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ä¸­ï¼Œå¯¹äºä»»æ„ä¸¤ä¸ªç‚¹$u,v$ï¼Œå­˜åœ¨ä¸€ä¸ªè·¯å¾„ï¼Œä½¿å¾—$u,v$è¿é€šã€‚

### Tarjan ç®—æ³•æ±‚å¼ºè¿é€šåˆ†é‡

é¦–å…ˆå®šä¹‰ä¸¤ä¸ªæ•°ç»„ `dfn`,`low` ã€‚å¯¹äºå›¾ä¸Šä»»æ„ä¸€ç‚¹$v$ï¼Œ$dfn_v$
è¡¨ç¤ºåœ¨ä¸€ä¸ªæ·±åº¦ä¼˜å…ˆæœç´¢æ ‘ä¸­ï¼Œè®¿é—®åˆ°èŠ‚ç‚¹$v$çš„åºå·ï¼ˆä»1å¼€å§‹)ï¼Œè€Œæ•°ç»„`low` åˆ™è¡¨ç¤ºèŠ‚ç‚¹$v$çš„å­æ ‘å’Œä¸å­æ ‘é€šè¿‡éæœç´¢è¾¹è¿æ¥çš„èŠ‚ç‚¹çš„`dfn`çš„æœ€å°å€¼ã€‚  
ä»£ç å®ç°ï¼š  

```cpp
#include<algorithm>
#include<vector>

#define maxn 1e5

using namespace std;

vector <int> g[maxn],stk;
int dfn[maxn],low[maxn],dfncnt,sc,scc[maxn],sz[maxn];
bool in_stk[maxn];

void tarjan(int u) {
    dfn[u]=low[u]=++dfncnt;
    stk.push_back(u);
    in_stk[u]=true;
    for(auto v : g[u]) {
        if(!dfn[v]) {
            tarjan(v);
            low[u]=min(low[v],low[u]);
        }
        else if(in_stk[v]) {
            low[u]=min(low[u],dfn[v]);
        }
    }
    if(low[u]==dfn[u]) {
        sc++;
        while(stk.back()!=u) {
            scc[stk.back()]=sc;
            sz[sc]++;
            in_stk[stk.back()]=false;
            stk.pop_back();
        }
        scc[stk.back()]=sc;
        sz[sc]++;
        in_stk[stk.back()]=false;
        stk.pop_back();
    }
}
